import sys
import binascii
import re
from datetime import datetime

TIME_FORMAT = "%M:%S.%f"

#Global header for pcap 2.4
pcap_global_header =   ('D4 C3 B2 A1'   
                        '02 00'         #File format major revision (i.e. pcap <2>.4)  
                        '04 00'         #File format minor revision (i.e. pcap 2.<4>)   
                        '00 00 00 00'     
                        '00 00 00 00'     
                        'FF FF 00 00'     
                        '01 00 00 00')  #Network type (IEEE 802.15.4 = 230 = 0xE6)

#pcap packet header that must preface every packet
pcap_packet_header =   ('SS SS SS SS'   #Timestamp (seconds)
                        'MS MS MS MS'   #Timestamp (microseconds)
                        'XX XX XX XX'   #Frame Size (little endian) 
                        'YY YY YY YY')  #Frame Size (little endian)

eth_header =   ('00 00 00 00 00 00'     #Source Mac    
                '00 00 00 00 00 00'     #Dest Mac  
                '08 00')                #Protocol (0x0800 = IP)

ip_header =    ('6B'                    #IP version and header length (multiples of 4 bytes)   
                '00'                      
                'XX XX'                 #Length - will be calculated and replaced later
                '00 00'                   
                '40 00 40'                
                '11'                    #Protocol (0x11 = UDP)          
                'YY YY'                 #Checksum - will be calculated and replaced later      
                'SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS SS'           #Source IP
                'DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD')          #Dest IP

udp_header =   ('80 01'                   
                'XX XX'                 #Port - will be replaced later                   
                'YY YY'                 #Length - will be calculated and replaced later        
                '00 00')
                
def getByteLength(str1):
    return len(''.join(str1.split())) / 2

def writeByteStringToFile(bytestring, filename):
    print(bytestring)
    bytelist = bytestring.split()  
    bytes = binascii.a2b_hex(''.join(bytelist))
    bitout = open(filename, 'ab')
    bitout.write(bytes)

def generatePCAP(input_file, output_file): 

    transmission_file = open(input_file, "r")

    while True:
        line = transmission_file.readline()
        if not line:
            break
        if not "[Packet Log]" in line:
            continue
        message = re.search("Message: '([^']+)'", line).group(1)
        receiver_address = re.search("received on ([^ ]+) ", line).group(1) + "Z"
        receiver_port = int(re.search("Port ([0-9]+) from", line).group(1))
        sender_address = re.search("from ([^ ]+) ", line).group(1) + "Z"
        sender_port = int(re.search("Port ([0-9]+)\n", line).group(1))
        time = re.search("([0-9]+:[0-9]{2}\.[0-9]{3})", line).group(1)
        time = datetime.combine(datetime.now().date(), datetime.strptime(time, TIME_FORMAT).time())
        seconds = int(time.timestamp())
        microseconds = int((time.timestamp() - seconds) * 1000000)

        # Recreate the shortened nullbyte strings
        if "::" in receiver_address:
            while receiver_address.count(":") < 7:
                receiver_address = receiver_address.replace("::", "::0000:")
            receiver_address = receiver_address.replace("::", ":0000:")

        if "::" in sender_address:
            while sender_address.count(":") < 7:
                sender_address = sender_address.replace("::", "::0000:")
        sender_address = sender_address.replace("::", ":0000:")
    
        while True:
            no_changes = True
            match = re.search("(:[0-9a-f]{1-3}[:Z])", sender_address)
            if match is not None and match.group(1) is not None:
                old = match.group(1)
                new = old
                while len(new) < 6:
                    new = new.replace(":", ":0", 1)
                sender_address = sender_address.replace(old, new)
                no_changes = False
            if no_changes:
                break

        while True:
            no_changes = True
            match = re.search("(:[0-9a-f]{1-3}[:Z])", receiver_address)
            if match is not None and match.group(1) is not None:
                old = match.group(1)
                new = old
                while len(new) < 6:
                    new = new.replace(":", ":0", 1)
                receiver_address = receiver_address.replace(old, new)
                no_changes = False
            if no_changes:
                break 
        
        sender_address = sender_address.upper().replace(":", " ").replace("Z", "")
        receiver_address = receiver_address.upper().replace(":", " ").replace("Z", "")

        udp = udp_header.replace('XX XX',"%04x" % receiver_port)
        udp_len = int(getByteLength(message) + getByteLength(udp_header))
        udp = udp.replace('YY YY',"%04x" % udp_len)

        ip_len = int(udp_len + getByteLength(ip_header))
        ip = ip_header.replace('XX XX',"%04x" % ip_len)
        ip = ip.replace('DD ' * 15 + 'DD', receiver_address)
        ip = ip.replace('SS ' * 15 + 'SS', sender_address)
        checksum = ip_checksum(ip.replace('YY YY','00 00'))
        ip = ip.replace('YY YY',"%04x" % checksum)
    
        pcap_len = int(ip_len + getByteLength(eth_header))
        hex_str = "%08x" % pcap_len
        reverse_hex_str = hex_str[6:] + hex_str[4:6] + hex_str[2:4] + hex_str[:2]
        pcaph = pcap_packet_header.replace('XX XX XX XX',reverse_hex_str)
        pcaph = pcaph.replace('YY YY YY YY',reverse_hex_str)
        pcaph = pcaph.replace('SS SS SS SS', "%08x" % seconds)
        pcaph = pcaph.replace('MS MS MS MS', "%08x" % microseconds)

        bytestring = pcap_global_header + pcaph + eth_header + ip + udp + binascii.hexlify(message.encode()).hex()
        writeByteStringToFile(bytestring, output_file)

#Splits the string into a list of tokens every n characters
def splitN(str1,n):
    return [str1[start:start+n] for start in range(0, len(str1), n)]

#Calculates and returns the IP checksum based on the given IP Header
def ip_checksum(iph):

    #split into bytes    
    words = splitN(''.join(iph.split()),4)

    csum = 0;
    for word in words:
        csum += int(word, base=16)

    csum += (csum >> 16)
    csum = csum & 0xFFFF ^ 0xFFFF

    return csum


"""------------------------------------------"""
""" End of functions, execution starts here: """
"""------------------------------------------"""

if len(sys.argv) < 3:
#        print 'usage: ' + sys.argv[0] + ' cooja_file output_file'
    print('usage: ' + sys.argv[0] + ' cooja_file output_file')
    exit(0)

generatePCAP(sys.argv[1], sys.argv[2])
